#summary System Feature - Building Controller

= Overview =

A Building Controller is a logical entity that defines a building in the game. A controller has other entities that act as "interfaces" to it. An entity that interfaces a controller can be used to not only damage the building, but also get information about the building to the player via the HUD.

The Controller is also responsible for handling the building's game logic and its Lua script instance.

A Script Bind also exists that allows the Script System to communicate with the instance of this Building Controller. It takes the form of the "controller" table in the Building Controller's script table.


= Functionality =

== !BuildingController ==
Below are the methods defined in the !BuildingController interface.

=== *_ Destructor _* ===
*Purpose*:
Undefined.

*Arguments*:
void

*Returns*:
void


=== *_ !GetMemoryStatistics _* ===
*Purpose*:
Used by memory management

*Arguments*:
 * _s_ - `[In]` Cry Sizer object

*Returns*:
void


=== *_ Initialize _* ===
*Purpose*:
Initialize the controller

*Arguments*:
 * _fHealth_ - `[In]` Initial health
 * _nGUID_ - `[In]` Building controller's GUID

*Returns*:
void


=== *_ Shutdown _* ===
*Purpose*:
Shut the controller down

*Arguments*:
void

*Returns*:
void


=== *_ Reset _* ===
*Purpose*:
Reset the controller back to its

*Arguments*:
void

*Returns*:
void


=== *_ !BeforeValidate _* ===
*Purpose*:
Prepare the controller for validation

*Arguments*:
void

*Returns*:
TRUE if validation should proceed, or FALSE if it should be skipped


=== *_ Validate _* ===
*Purpose*:
Validate the controller by checking for

*Arguments*:
void

*Returns*:
void


=== *_ !LoadFromXml _* ===
*Purpose*:
Define the building controller's attributes from the given XML file

*Arguments*:
 * _szName_ - `[In]` Class name of the building

*Returns*:
TRUE if building controller is ready


=== *_ !GetGUID _* ===
*Purpose*:
Return the controller's GUID

*Arguments*:
void

*Returns*:
void


=== *_ !GetScriptTable _* ===
*Purpose*:
Return the script table attatched to the controller's script

*Arguments*:
void

*Returns*:
void


=== *_ !GetTeam _* ===
*Purpose*:
Returns owning team's ID or TEAMID_NOTEAM if there is no team

*Arguments*:
void

*Returns*:
void


=== *_ !GetTeamName _* ===
*Purpose*:
Returns owning team's name

*Arguments*:
void

*Returns*:
void


=== *_ !GetClass _* ===
*Purpose*:
Returns building class or BC_INVALID if there is no class

*Arguments*:
void

*Returns*:
void


=== *_ !GetClassName _* ===
*Purpose*:
Returns owning class' name

*Arguments*:
void

*Returns*:
void


=== *_ !AddInterface _* ===
*Purpose*:
Mark an entity as an interface to this controller

*Arguments*:
 * _pEntity_ - `[In]` Entity to use

*Returns*:
TRUE if entity is acting as an interface to it now or FALSE if not

*Note*:
Sets the ENTITY_FLAG_ISINTERFACE on the enemy so the same entity cannot interface more than one building at the same time!

=== *_ !RemoveInterface _* ===
*Purpose*:
Remove an entity as an interface to this controller

*Arguments*:
 * _pEntity_ - `[In]` Entity to remove

*Returns*:
void


== !ScriptBind_BuildingController ==
Below are the methods defined in the !ScriptBind_BuildingController module.

=== *_ !RegisterGlobals _* ===
*Purpose*:
Called to register global variables

*Arguments*:
void

*Returns*:
void


=== *_ !RegisterMethods _* ===
*Purpose*:
Called to register function methods

*Arguments*:
void

*Returns*:
void


=== *_ !GetController _* ===
*Purpose*:
Return the controller

*Arguments*:
 * _pH_ - `[In]` Function handler to get controller from

*Returns*:
void


=== *_ Constructor _* ===
*Purpose*:
Undefined.

*Arguments*:
 * _pGameFW_ - `[In]` Game frame work object
 * _pSystem_ - `[In]` System object

*Returns*:
void


=== *_ Destructor _* ===
*Purpose*:
Undefined.

*Arguments*:
void

*Returns*:
void


=== *_ !AttachTo _* ===
*Purpose*:
Bind to a controller

*Arguments*:
 * _pController_ - `[In]` Controller to be bound

*Returns*:
void



= Adding an Interface =
Interfaces are added to a Building Controller in one of two ways: either A.) Automatically if the entity's script table has the *CNCBuilding* table defined in its _Properties_ table, or B.) If manually added.

== CNCBuilding Table ==
An example of where this table is defined is the GeomEntity entity.

This table contains two properties:
 * Team = Name of the team that owns the building
 * Class = Class type of the building to interface

These two values are used to construct the GUID of the Building Controller that should be interfaced. If valid, this entity is automatically added as an interface to the controller after the level has loaded and each time the level is reset.


[TechDoc_Architecture Back]