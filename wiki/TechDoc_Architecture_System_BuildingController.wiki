#summary System Feature - Building Controller

= Overview =

A Building Controller is a logical entity that defines a building in the game. A controller has other entities that act as "interfaces" to it. An entity that interfaces a controller can be used to not only damage the building, but also get information about the building to the player via the HUD.

The Controller is also responsible for handling the building's game logic and its Lua script instance.

A Script Bind also exists that allows the Script System to communicate with the instance of this Building Controller. It takes the form of the "controller" table in the Building Controller's script table.


= Functionality =

== !SControllerEvent ==
Below are the methods defined in the !SControllerEvent object.

== !BuildingControllerEventListener ==
Below are the methods defined in the !BuildingControllerEventListener interface.

=== *_ !OnBuildingControllerEvent _* ===
*Purpose*:
Called when event occurs on controller

*Arguments*:
 * _event_ - `[In]` Event that occured
 * _nGUID_ - `[In]` Controller's BuildingGUID
 * _pController_ - `[In]` Building controller object

*Returns*:
void

*Note*:
See SControllerEvent

== !BuildingController ==
Below are the methods defined in the !BuildingController interface.

=== *_ Destructor _* ===
*Purpose*:
Undefined.

*Arguments*:
void

*Returns*:
void


=== *_ !GetMemoryStatistics _* ===
*Purpose*:
Used by memory management

*Arguments*:
 * _s_ - `[In]` Cry Sizer object

*Returns*:
void


=== *_ Initialize _* ===
*Purpose*:
Initialize the controller

*Arguments*:
 * _nGUID_ - `[In]` Building controller's GUID

*Returns*:
void


=== *_ Shutdown _* ===
*Purpose*:
Shut the controller down

*Arguments*:
void

*Returns*:
void


=== *_ Update _* ===
*Purpose*:
Update the controller

*Arguments*:
 * _bHaveFocus_ - `[In]` TRUE if game has focus
 * _nControllerUpdateFlags_ - `[In]` Controller-specific update flags (see EControllerUpdateFlags)
 * _nUpdateFlags_ - `[In]` Update flags

*Returns*:
void


=== *_ Reset _* ===
*Purpose*:
Reset the controller back to its

*Arguments*:
void

*Returns*:
void


=== *_ !BeforeValidate _* ===
*Purpose*:
Prepare the controller for validation

*Arguments*:
void

*Returns*:
TRUE if validation should proceed, or FALSE if it should be skipped


=== *_ Validate _* ===
*Purpose*:
Validate the controller by checking for

*Arguments*:
void

*Returns*:
void


=== *_ !IsValidated _* ===
*Purpose*:
Returns TRUE if building has been validated

*Arguments*:
void

*Returns*:
void


=== *_ !LoadFromXml _* ===
*Purpose*:
Define the building controller's attributes from the given XML node

*Arguments*:
 * _pNode_ - `[In]` XML Node containing its attributes

*Returns*:
void


=== *_ !GetGUID _* ===
*Purpose*:
Return the controller's GUID

*Arguments*:
void

*Returns*:
void


=== *_ !GetScriptTable _* ===
*Purpose*:
Return the script table attatched to the controller's script

*Arguments*:
void

*Returns*:
void


=== *_ !GetTeam _* ===
*Purpose*:
Returns owning team's ID or TEAMID_NOTEAM if there is no team

*Arguments*:
void

*Returns*:
void


=== *_ !GetTeamName _* ===
*Purpose*:
Returns owning team's name

*Arguments*:
void

*Returns*:
void


=== *_ !GetClass _* ===
*Purpose*:
Returns building class or BC_INVALID if there is no class

*Arguments*:
void

*Returns*:
void


=== *_ !GetClassName _* ===
*Purpose*:
Returns owning class' name

*Arguments*:
void

*Returns*:
void


=== *_ !AddInterface _* ===
*Purpose*:
Mark an entity as an interface to this controller

*Arguments*:
 * _pEntity_ - `[In]` Entity to use

*Returns*:
TRUE if entity is acting as an interface to it now or FALSE if not

*Note*:
Sets the ENTITY_FLAG_ISINTERFACE on the enemy so the same entity cannot interface more than one building at the same time!

=== *_ !RemoveInterface _* ===
*Purpose*:
Remove an entity as an interface to this controller

*Arguments*:
 * _pEntity_ - `[In]` Entity to remove

*Returns*:
void


=== *_ !HasInterface _* ===
*Purpose*:
Returns TRUE if the given entity is an

*Arguments*:
 * _nEntityId_ - `[In]` Entity to check
 * _pEntity_ - `[In]` Entity to check

*Returns*:
void


=== *_ !IsVisible _* ===
*Purpose*:
Returns TRUE if the controller is visible to the player (i.e. player is focused on an

*Arguments*:
void

*Returns*:
void


=== *_ !SetMustBeDestroyed _* ===
*Purpose*:
Set if building wants to be destroyed for the team to lose

*Arguments*:
 * _b_ - `[In]` TRUE if it must be destroyed

*Returns*:
void

*Note*:
Will be ignored if building is not interfaced

=== *_ !MustBeDestroyed _* ===
*Purpose*:
Returns TRUE if building must be destroyed for the team to lose

*Arguments*:
void

*Returns*:
void


=== *_ !AddEventListener _* ===
*Purpose*:
Add an event listener to controller

*Arguments*:
 * _pListener_ - `[In]` Listening object

*Returns*:
void


=== *_ !RemoveEventListener _* ===
*Purpose*:
Remove an event listener from controller

*Arguments*:
 * _pListener_ - `[In]` Listening object

*Returns*:
void


=== *_ !AddScriptEventListener _* ===
*Purpose*:
Add an event listener to an entity's script

*Arguments*:
 * _nID_ - `[In]` Entity Id

*Returns*:
TRUE if added

*Note*:
Will call the entity's script's "OnBuildingEvent" when an event occurs

=== *_ !RemoveScriptEventListener _* ===
*Purpose*:
Remove an event listener from an entity's script

*Arguments*:
 * _nID_ - `[In]` Entity Id

*Returns*:
void


=== *_ !OnClientHit _* ===
*Purpose*:
Call when a hit occurs on the client

*Arguments*:
 * _hitinfo_ - `[In]` Hit information

*Returns*:
void


=== *_ !OnServerHit _* ===
*Purpose*:
Call when a hit occurs on the server

*Arguments*:
 * _hitinfo_ - `[In]` Hit information

*Returns*:
void


=== *_ !OnClientExplosion _* ===
*Purpose*:
Call when an explosion occurs on the client

*Arguments*:
 * _explosionInfo_ - `[In]` Explosion information
 * _fObstruction_ - `[In]` Obstruction ratio (0 = fully obstructed, 1 = fully visible)
 * _nInterfaceId_ - `[In]` ID of interface entity that was hit by this explosion

*Returns*:
void


=== *_ !OnServerExplosion _* ===
*Purpose*:
Call when an explosion occurs on the server

*Arguments*:
 * _explosionInfo_ - `[In]` Explosion information
 * _fObstruction_ - `[In]` Obstruction ratio (0 = fully obstructed, 1 = fully visible)
 * _nInterfaceId_ - `[In]` ID of interface entity that was hit by this explosion

*Returns*:
void


=== *_ !HasPower _* ===
*Purpose*:
Returns TRUE if the building has power

*Arguments*:
void

*Returns*:
void


=== *_ !SetPower _* ===
*Purpose*:
Set the power status of the building

*Arguments*:
 * _bPowered_ - `[In]` TRUE to give it power, FALSE to take it away

*Returns*:
void


=== *_ !GetHealth _* ===
*Purpose*:
Get the building's current health amount

*Arguments*:
void

*Returns*:
void


=== *_ !IsAlive _* ===
*Purpose*:
Returns TRUE if the building is alive or FALSE if it is dead

*Arguments*:
void

*Returns*:
void


== !ScriptBind_BuildingController ==
Below are the methods defined in the !ScriptBind_BuildingController module.

=== *_ !RegisterGlobals _* ===
*Purpose*:
Called to register global variables

*Arguments*:
void

*Returns*:
void


=== *_ !RegisterMethods _* ===
*Purpose*:
Called to register function methods

*Arguments*:
void

*Returns*:
void


=== *_ !GetController _* ===
*Purpose*:
Return the controller

*Arguments*:
 * _pH_ - `[In]` Function handler to get controller from

*Returns*:
void


=== *_ Constructor _* ===
*Purpose*:
Undefined.

*Arguments*:
 * _pGameFW_ - `[In]` Game frame work object
 * _pSystem_ - `[In]` System object

*Returns*:
void


=== *_ Destructor _* ===
*Purpose*:
Undefined.

*Arguments*:
void

*Returns*:
void


=== *_ !AttachTo _* ===
*Purpose*:
Bind to a controller

*Arguments*:
 * _pController_ - `[In]` Controller to be bound

*Returns*:
void


=== *_ !GetHealth _* ===
*Purpose*:
Get the health of the building

*Arguments*:
void

*Returns*:
void


=== *_ !IsAlive _* ===
*Purpose*:
Returns TRUE if building is alive

*Arguments*:
void

*Returns*:
void


=== *_ !HasPower _* ===
*Purpose*:
Returns TRUE if building has power

*Arguments*:
void

*Returns*:
void


=== *_ !SetPower _* ===
*Purpose*:
Set the power of the building

*Arguments*:
 * _bPower_ - `[In]` TRUE to give it power, FALSE to take it away

*Returns*:
void


=== *_ !AddEventListener _* ===
*Purpose*:
Add the given entity to the entity event listener on the controller

*Arguments*:
 * _nEntityID_ - `[In]` Entity Id to add

*Returns*:
'1' if succeeded, nil if not


=== *_ !RemoveEventListener _* ===
*Purpose*:
Remove the given entity from the entity event listener on the controller

*Arguments*:
 * _nEntityID_ - `[In]` Entity Id to add

*Returns*:
void



= Adding an Interface =
Interfaces are added to a Building Controller in one of two ways: either A.) Automatically if the entity's script table has the *CNCBuilding* table defined in its _Properties_ table, or B.) If manually added.

== CNCBuilding Table ==
An example of where this table is defined is the GeomEntity entity.

This table contains two properties:
 * Team = Name of the team that owns the building
 * Class = Class type of the building to interface

These two values are used to construct the GUID of the Building Controller that should be interfaced. If valid, this entity is automatically added as an interface to the controller after the level has loaded and each time the level is reset.


[TechDoc_Architecture Back]